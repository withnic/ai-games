<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãŠæƒé™¤ã‚²ãƒ¼ãƒ  v5.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– */
        }
        .game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 4 / 3;
            cursor: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¼ã‚½ãƒ«ã‚’éè¡¨ç¤º */
            background-color: #f0e6d2; /* åºŠã®è‰² */
            border-radius: 0.5rem;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        #cursor {
            position: absolute;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none; /* ã‚«ãƒ¼ã‚½ãƒ«ãŒãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¦¨ã’ãªã„ã‚ˆã†ã«ã™ã‚‹ */
            transform: translate(-50%, -50%);
            mix-blend-mode: difference; /* èƒŒæ™¯è‰²ã«å¿œã˜ã¦è‰²ãŒå¤‰ã‚ã‚‹ */
            transition: width 0.2s, height 0.2s; /* ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’æ»‘ã‚‰ã‹ã« */
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl font-bold text-gray-700 mb-4">ãŠæƒé™¤ã‚²ãƒ¼ãƒ </h1>

    <!-- æƒ…å ±è¡¨ç¤ºãƒ‘ãƒãƒ« -->
    <div class="w-full max-w-2xl bg-white p-4 rounded-lg shadow-md mb-4">
        <div class="flex justify-between items-center">
            <div>
                <span class="text-lg text-gray-600">ã‚¹ãƒ†ãƒ¼ã‚¸: <span id="stageLevel">1</span></span>
            </div>
            <div>
                <span class="text-lg text-yellow-600">ğŸ’°: <span id="money">0</span></span>
            </div>
            <div class="w-1/3">
                 <div class="w-full bg-gray-200 rounded-full h-6">
                    <div id="dirtProgress" class="bg-yellow-800 h-6 rounded-full text-xs font-medium text-blue-100 text-center p-1 leading-none transition-all duration-300" style="width: 100%">
                        <span id="dirtPercentage">æ±šã‚Œ: 100%</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="text-center mt-2">
            <span class="text-gray-500">ç¾åœ¨ã®é“å…·: <span id="currentToolName">é›‘å·¾</span></span>
        </div>
        <!-- ç´¯è¨ˆãŠæƒé™¤è¨˜éŒ² -->
        <div class="text-center mt-4 border-t pt-4">
            <h2 class="text-xl font-bold text-gray-700">ç´¯è¨ˆãŠæƒé™¤è¨˜éŒ²</h2>
            <p class="text-lg text-gray-600 mt-2">
                åˆè¨ˆãŠæƒé™¤é¢ç©: <span id="totalArea" class="font-bold text-blue-600">0.00ã¡</span>
            </p>
            <p id="equivalent" class="text-md text-green-600 mt-1 h-6"></p>
        </div>
    </div>

    <div id="gameContainer" class="game-container rounded-lg shadow-lg">
        <canvas id="dirtCanvas"></canvas>
        <canvas id="effectCanvas"></canvas>
        <div id="cursor"></div>
    </div>
    
    <div id="messageArea" class="mt-4 h-8 text-xl font-bold text-green-600"></div>

    <!-- ã‚¹ãƒˆã‚¢ã®ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="storeModal" class="modal-backdrop hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <!-- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å†…ã®ãŠæƒé™¤çµæœ -->
            <div class="text-center mb-4 border-b pb-4">
                <h3 class="text-xl font-bold text-gray-700">ä»Šå›ã®ãŠæƒé™¤çµæœ</h3>
                <p class="text-lg text-gray-600 mt-2">
                    åˆè¨ˆãŠæƒé™¤é¢ç©: <span id="modalTotalArea" class="font-bold text-blue-600">0.00ã¡</span>
                </p>
                <p id="modalEquivalent" class="text-md text-green-600 mt-1 h-6"></p>
                <p class="text-lg text-yellow-600 mt-2">
                    ç²å¾—å ±é…¬: <span id="modalReward" class="font-bold">0</span>å††
                </p>
            </div>

            <h2 class="text-2xl font-bold text-center mb-4">é“å…·ã‚¹ãƒˆã‚¢</h2>
            <div id="toolList" class="space-y-3">
                <!-- é“å…·ã¯ã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>
            <div class="text-center mt-6">
                <button id="nextStageButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">
                    æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
                </button>
            </div>
        </div>
    </div>

<script>
// =================================
// ã‚²ãƒ¼ãƒ ã®åˆæœŸè¨­å®š
// =================================
const dirtCanvas = document.getElementById('dirtCanvas');
const dirtCtx = dirtCanvas.getContext('2d');
const effectCanvas = document.getElementById('effectCanvas');
const effectCtx = effectCanvas.getContext('2d');
const cursor = document.getElementById('cursor');

// UIè¦ç´ 
const stageLevelUI = document.getElementById('stageLevel');
const moneyUI = document.getElementById('money');
const dirtPercentageUI = document.getElementById('dirtPercentage');
const dirtProgressUI = document.getElementById('dirtProgress');
const currentToolNameUI = document.getElementById('currentToolName');
const messageArea = document.getElementById('messageArea');
const totalAreaUI = document.getElementById('totalArea');
const equivalentUI = document.getElementById('equivalent');
const storeModal = document.getElementById('storeModal');
const toolListUI = document.getElementById('toolList');
const nextStageButton = document.getElementById('nextStageButton');
const modalTotalAreaUI = document.getElementById('modalTotalArea');
const modalEquivalentUI = document.getElementById('modalEquivalent');
const modalRewardUI = document.getElementById('modalReward');

// ã‚°ãƒªãƒƒãƒ‰è¨­å®š
const CELL_SIZE = 10; // æ±šã‚Œã‚’ç®¡ç†ã™ã‚‹ã‚°ãƒªãƒƒãƒ‰ã®1ã‚»ãƒ«ã®å¤§ãã•
const CELL_AREA_M2 = (CELL_SIZE * CELL_SIZE) / 10000; // 1ã‚»ãƒ«ã‚ãŸã‚Šã®é¢ç©(m^2)
let GRID_COLS, GRID_ROWS;
let dirtGrid = [];

// ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
let gameState = {
    isDrawing: false,
    stage: 1,
    money: 0,
    currentToolId: 'rag',
    totalHealth: 0,
    remainingHealth: 0,
    stageDirtReward: 0,
    totalAreaCleaned: 0, // ç´¯è¨ˆãŠæƒé™¤é¢ç© (m^2)
    isCleared: false,
    sparkles: [],
    isToneStarted: false,
};

// é“å…·ã®ãƒ‡ãƒ¼ã‚¿
const tools = {
    rag: { name: 'é›‘å·¾', radius: 15, price: 0 },
    mop: { name: 'ãƒ¢ãƒƒãƒ—', radius: 30, price: 100 },
    deck_brush: { name: 'ãƒ‡ãƒƒã‚­ãƒ–ãƒ©ã‚·', radius: 50, price: 500 },
    polisher: { name: 'ãƒãƒªãƒƒã‚·ãƒ£ãƒ¼', radius: 80, price: 2000 },
};

// æ±šã‚Œã®ç¨®é¡
const dirtTypes = {
    mud:   { name: 'æ³¥æ±šã‚Œ', color: '#8B4513', health: 1, reward: 1 },
    oil:   { name: 'æ²¹æ±šã‚Œ', color: '#4a4a4a', health: 2, damagedColor: '#787878', reward: 3 },
    juice: { name: 'ã‚¸ãƒ¥ãƒ¼ã‚¹ã®ã‚·ãƒŸ', color: '#800080', health: 1, reward: 2 },
    dust:  { name: 'ãƒ›ã‚³ãƒª', color: '#b2b2b2', health: 1, reward: 1 }
};

// é¢ç©ã®æ¯”è¼ƒå¯¾è±¡
const areaEquivalents = [
    { name: 'ä¸€èˆ¬çš„ãªãƒã‚¹ã‚¿ãƒ–', area: 1.5, unit: 'å€‹' },
    { name: 'å“çƒå°', area: 4.2, unit: 'å°' },
    { name: 'ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ ãƒãƒ³ã‚·ãƒ§ãƒ³', area: 25, unit: 'éƒ¨å±‹' },
    { name: 'å­¦æ ¡ã®æ•™å®¤', area: 64, unit: 'éƒ¨å±‹' },
    { name: 'ã‚³ãƒ³ãƒ“ãƒ‹', area: 100, unit: 'åº—èˆ—' },
    { name: 'ãƒ†ãƒ‹ã‚¹ã‚³ãƒ¼ãƒˆ', area: 260, unit: 'é¢' },
    { name: 'ãƒã‚¹ã‚±ãƒƒãƒˆãƒœãƒ¼ãƒ«ã‚³ãƒ¼ãƒˆ', area: 420, unit: 'é¢' },
    { name: '25mãƒ—ãƒ¼ãƒ«', area: 300, unit: 'å€‹' },
    { name: 'ã‚ªãƒªãƒ³ãƒ”ãƒƒã‚¯ãƒ—ãƒ¼ãƒ«', area: 1250, unit: 'å€‹' },
    { name: 'ã‚µãƒƒã‚«ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', area: 7140, unit: 'é¢' },
    { name: 'æ±äº¬ãƒ‰ãƒ¼ãƒ ï¼ˆã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼‰', area: 13000, unit: 'å€‹' }
].sort((a, b) => a.area - b.area);

// ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
const sounds = {
    purchase: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(),
    stageClear: new Tone.PolySynth(Tone.Synth, { oscillator: { type: "fatsawtooth" } }).toDestination()
};

// =================================
// ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã¨ãƒªã‚µã‚¤ã‚ºå‡¦ç†
// =================================
function setupCanvas() {
    const container = document.getElementById('gameContainer');
    const size = container.clientWidth;
    const height = size * (3 / 4);
    
    dirtCanvas.width = size;
    dirtCanvas.height = height;
    effectCanvas.width = size;
    effectCanvas.height = height;

    GRID_COLS = Math.floor(dirtCanvas.width / CELL_SIZE);
    GRID_ROWS = Math.floor(dirtCanvas.height / CELL_SIZE);
    
    const currentTool = tools[gameState.currentToolId];
    cursor.style.width = `${currentTool.radius * 2}px`;
    cursor.style.height = `${currentTool.radius * 2}px`;

    startStage();
}

// =================================
// ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç®¡ç†
// =================================
function startStage() {
    gameState.isCleared = false;
    messageArea.textContent = '';
    storeModal.classList.add('hidden');
    
    dirtGrid = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
    dirtCtx.clearRect(0, 0, dirtCanvas.width, dirtCanvas.height);
    
    if (gameState.stage === 1) {
        generateDirtPatch(Math.floor(GRID_COLS / 4), Math.floor(GRID_ROWS / 4), Math.floor(GRID_COLS / 2), Math.floor(GRID_ROWS / 2), 'mud');
    } else {
        const patchCount = Math.min(5 + gameState.stage, 15);
        for (let i = 0; i < patchCount; i++) {
            const x = Math.floor(Math.random() * GRID_COLS);
            const y = Math.floor(Math.random() * GRID_ROWS);
            const width = Math.floor(Math.random() * (GRID_COLS / 4)) + 5;
            const height = Math.floor(Math.random() * (GRID_ROWS / 4)) + 5;
            const dirtKeys = Object.keys(dirtTypes);
            const type = dirtKeys[Math.floor(Math.random() * dirtKeys.length)];
            generateDirtPatch(x, y, width, height, type);
        }
    }
    
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    gameState.sparkles = [];
    
    calculateDirtAmount(true);
    updateUI();
    updateTotalAreaDisplay();
}

function generateDirtPatch(startX, startY, width, height, type) {
    const dirt = dirtTypes[type];
    for (let r = startY; r < startY + height && r < GRID_ROWS; r++) {
        for (let c = startX; c < startX + width && c < GRID_COLS; c++) {
            if (dirtGrid[r][c] === null) {
                dirtGrid[r][c] = { type: type, health: dirt.health, lastHit: 0 };
                dirtCtx.fillStyle = dirt.color;
                dirtCtx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
    }
}


// =================================
// æç”»ã¨æ±šã‚Œã®å‡¦ç†
// =================================
function getEventPos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clientX = evt.clientX || evt.touches[0].clientX;
    const clientY = evt.clientY || evt.touches[0].clientY;
    return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
}

function clean(e) {
    if (!gameState.isDrawing || gameState.isCleared) return;
    
    const pos = getEventPos(dirtCanvas, e);
    const currentTool = tools[gameState.currentToolId];
    const toolRadiusInGrid = currentTool.radius / CELL_SIZE;
    const gridX = Math.floor(pos.x / CELL_SIZE);
    const gridY = Math.floor(pos.y / CELL_SIZE);

    for (let r = Math.max(0, Math.floor(gridY - toolRadiusInGrid)); r <= Math.min(GRID_ROWS - 1, Math.floor(gridY + toolRadiusInGrid)); r++) {
        for (let c = Math.max(0, Math.floor(gridX - toolRadiusInGrid)); c <= Math.min(GRID_COLS - 1, Math.floor(gridX + toolRadiusInGrid)); c++) {
            const dx = (c - gridX);
            const dy = (r - gridY);
            if (dx * dx + dy * dy <= toolRadiusInGrid * toolRadiusInGrid) {
                const dirt = dirtGrid[r][c];
                if (dirt) {
                    const now = Date.now();
                    if (now - dirt.lastHit > 100) {
                        dirt.health--;
                        dirt.lastHit = now;

                        if (dirt.health <= 0) {
                            dirtGrid[r][c] = null;
                            dirtCtx.clearRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                            gameState.totalAreaCleaned += CELL_AREA_M2;
                            updateTotalAreaDisplay();
                        } else if (dirt.type === 'oil') {
                            dirtCtx.fillStyle = dirtTypes.oil.damagedColor;
                            dirtCtx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
            }
        }
    }
}

function calculateDirtAmount(isInitial = false) {
    if (gameState.isCleared) return;
    
    let currentHealth = 0;
    let dirtReward = 0;
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const cell = dirtGrid[r][c];
            if (cell) {
                currentHealth += cell.health;
                if(isInitial) {
                    const dirtInfo = dirtTypes[cell.type];
                    dirtReward += dirtInfo.health * dirtInfo.reward;
                }
            }
        }
    }

    if (isInitial) {
        gameState.totalHealth = currentHealth;
        gameState.stageDirtReward = dirtReward;
    }
    gameState.remainingHealth = currentHealth;
    updateDirtUI();

    const remainingPercentage = gameState.totalHealth > 0 ? (gameState.remainingHealth / gameState.totalHealth) * 100 : 0;
    
    if (remainingPercentage <= 0.1 && !gameState.isCleared) {
        playSparkleEffect();
        stageClear();
    }
}

// =================================
// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
// =================================
function playSparkleEffect() {
    if (gameState.sparkles.length > 0) return;
    for (let i = 0; i < 50; i++) {
        gameState.sparkles.push({
            x: Math.random() * effectCanvas.width,
            y: Math.random() * effectCanvas.height,
            size: Math.random() * 2 + 1,
            opacity: Math.random() * 0.5 + 0.5,
            life: Math.random() * 50 + 20,
        });
    }
    if (gameState.sparkles.length > 0) animateSparkles();
}

function animateSparkles() {
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    for (let i = gameState.sparkles.length - 1; i >= 0; i--) {
        const s = gameState.sparkles[i];
        s.life--;
        if (s.life <= 0) {
            gameState.sparkles.splice(i, 1);
            continue;
        }
        effectCtx.beginPath();
        effectCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        effectCtx.fillStyle = `rgba(255, 255, 100, ${s.opacity * (s.life / 50)})`;
        effectCtx.fill();
    }
    if (gameState.sparkles.length > 0) requestAnimationFrame(animateSparkles);
}


// =================================
// UIã®æ›´æ–°
// =================================
function updateUI() {
    stageLevelUI.textContent = gameState.stage;
    moneyUI.textContent = gameState.money;
    currentToolNameUI.textContent = tools[gameState.currentToolId].name;
    updateDirtUI();
}

function updateDirtUI() {
    if (gameState.totalHealth === 0) {
        dirtPercentageUI.textContent = `æ±šã‚Œ: 0.0%`;
        dirtProgressUI.style.width = `0%`;
        return;
    };
    const percentage = Math.max(0, (gameState.remainingHealth / gameState.totalHealth) * 100);
    dirtPercentageUI.textContent = `æ±šã‚Œ: ${percentage.toFixed(1)}%`;
    dirtProgressUI.style.width = `${percentage}%`;
}

function updateTotalAreaDisplay() {
    totalAreaUI.textContent = `${gameState.totalAreaCleaned.toFixed(2)}ã¡`;

    let bestEquivalent = null;
    for (let i = areaEquivalents.length - 1; i >= 0; i--) {
        if (gameState.totalAreaCleaned >= areaEquivalents[i].area) {
            bestEquivalent = areaEquivalents[i];
            break;
        }
    }

    let equivalentText = 'ã¾ã ã¾ã ãŠæƒé™¤ãŒå¿…è¦ã§ã™ï¼';
    if (bestEquivalent) {
        const count = (gameState.totalAreaCleaned / bestEquivalent.area).toFixed(1);
        equivalentText = `ã“ã‚Œã¯${bestEquivalent.name} ç´„${count}${bestEquivalent.unit}åˆ†ã§ã™ï¼`;
    }
    
    equivalentUI.textContent = equivalentText;
    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å†…ã®è¡¨ç¤ºã‚‚æ›´æ–°
    modalTotalAreaUI.textContent = `${gameState.totalAreaCleaned.toFixed(2)}ã¡`;
    modalEquivalentUI.textContent = equivalentText;
}

// =================================
// ã‚¹ãƒˆã‚¢ã®å‡¦ç†
// =================================
function populateStore() {
    toolListUI.innerHTML = '';
    Object.keys(tools).forEach(toolId => {
        const tool = tools[toolId];
        if (tool.price === 0) return;
        const isOwned = Object.keys(tools).indexOf(toolId) <= Object.keys(tools).indexOf(gameState.currentToolId);
        const canAfford = gameState.money >= tool.price;
        const buttonDisabled = isOwned || !canAfford;
        const buttonClass = isOwned ? 'bg-gray-400 cursor-not-allowed' : canAfford ? 'bg-green-500 hover:bg-green-600' : 'bg-red-400 cursor-not-allowed';
        const buttonText = isOwned ? 'è³¼å…¥æ¸ˆã¿' : `è³¼å…¥ (${tool.price}å††)`;

        toolListUI.innerHTML += `
            <div class="flex items-center justify-between p-3 bg-gray-100 rounded-lg">
                <div>
                    <p class="font-bold text-lg">${tool.name}</p>
                    <p class="text-sm text-gray-600">æƒé™¤ç¯„å›²: ${tool.radius * 2}px</p>
                </div>
                <button onclick="buyTool('${toolId}')" class="text-white font-bold py-2 px-4 rounded-lg transition-colors ${buttonClass}" ${buttonDisabled ? 'disabled' : ''}>
                    ${buttonText}
                </button>
            </div>`;
    });
}

window.buyTool = function(toolId) {
    const tool = tools[toolId];
    if (gameState.money >= tool.price) {
        gameState.money -= tool.price;
        gameState.currentToolId = toolId;
        sounds.purchase.triggerAttackRelease("C5", "8n");
        const currentTool = tools[gameState.currentToolId];
        cursor.style.width = `${currentTool.radius * 2}px`;
        cursor.style.height = `${currentTool.radius * 2}px`;
        updateUI();
        populateStore();
    }
}

// =================================
// ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ã®åˆ¶å¾¡
// =================================
function stageClear() {
    if (gameState.isCleared) return;
    gameState.isCleared = true;
    
    let reward;
    if (gameState.stage === 1) {
        reward = 100;
    } else {
        reward = gameState.stageDirtReward + 50;
    }

    gameState.money += reward;
    
    sounds.stageClear.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", Tone.now());
    messageArea.textContent = `ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ${reward}å††ã‚²ãƒƒãƒˆï¼`;
    
    modalRewardUI.textContent = reward; // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®å ±é…¬ã‚’æ›´æ–°
    updateUI();
    updateTotalAreaDisplay(); // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤ºã®ãŸã‚ã«æœ€æ–°æƒ…å ±ã«æ›´æ–°
    populateStore();
    setTimeout(() => storeModal.classList.remove('hidden'), 1000);
}

function goToNextStage() {
    gameState.stage++;
    setupCanvas();
}

// =================================
// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
// =================================
function addEventListeners() {
    const container = document.getElementById('gameContainer');
    
    const startDrawing = (e) => {
        e.preventDefault();
        if (!gameState.isToneStarted) {
            Tone.start();
            gameState.isToneStarted = true;
        }
        gameState.isDrawing = true;
        clean(e);
    };

    const stopDrawing = () => {
        if (!gameState.isDrawing) return;
        gameState.isDrawing = false;
        calculateDirtAmount();
    };

    const draw = (e) => {
        e.preventDefault();
        const pos = getEventPos(dirtCanvas, e);
        cursor.style.left = `${pos.x}px`;
        cursor.style.top = `${pos.y}px`;
        clean(e);
    };
    
    container.addEventListener('mousedown', startDrawing);
    container.addEventListener('mouseup', stopDrawing);
    container.addEventListener('mousemove', draw);
    container.addEventListener('mouseleave', stopDrawing);
    container.addEventListener('touchstart', startDrawing, { passive: false });
    container.addEventListener('touchend', stopDrawing);
    container.addEventListener('touchmove', draw, { passive: false });
    nextStageButton.addEventListener('click', goToNextStage);
    window.addEventListener('resize', setupCanvas);
}

// =================================
// ã‚²ãƒ¼ãƒ é–‹å§‹
// =================================
window.onload = () => {
    setupCanvas();
    addEventListeners();
};

</script>
</body>
</html>
